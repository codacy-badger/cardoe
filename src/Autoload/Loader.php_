<?php
declare(strict_types=1);

/**
 * This file is part of the Cardoe Framework.
 *
 * For the full copyright and license information, please view the LICENSE.md
 * file that was distributed with this source code.
 */

namespace Cardoe\Autoload;

use Cardoe\Helper\Str;
use function array_merge;
use function is_array;
use function is_callable;
use const DIRECTORY_SEPARATOR;

/**
 * Class Logger
 *
 * @package Cardoe\Autoload
 *
 * @property array       $classes
 * @property array       $directories
 * @property array       $extensions
 * @property array       $files
 * @property array       $namespaces
 * @property bool        $registered
 */
class Loader
{
    /**
     * @var array
     */
    protected $classes = [];

    /**
     * @var array
     */
    protected $directories = [];

    /**
     * @var array
     */
    protected $extensions = ["php"];

    /**
     * @var array
     */
    protected $files = [];

    /**
     * @var array
     */
    protected $namespaces = [];

    /**
     * @var bool
     */
    protected $registered = false;

    /**
     * Autoloads the registered classes
     *
     * @param string $className
     *
     * @return bool
     */
    public function autoLoad(string $className): bool
    {
        /**
         * Classes
         */
        if (true === isset($this->classes[$className])) {
            require $this->classes[$className];

            return true;
        }

        $ds = DIRECTORY_SEPARATOR;
        $ns = "\\";

        /**
         * Namespaces
         */
        foreach ($this->namespaces as $nsPrefix => $directories) {
            if (true !== Str::startsWith($className, $nsPrefix)) {
                continue;
            }

            /**
             * Append the namespace separator to the prefix
             */
            $fileName = str_replace(
                $ns,
                $ds,
                substr($className, strlen($nsPrefix . $ns))
            );
            foreach ($directories as $directory) {
                /**
                 * Add a trailing directory separator if the user forgot to do
                 * that
                 */
                $fixedDirectory = rtrim($directory, $ds) . $ds;
                foreach ($this->extensions as $extension) {
                    $filePath = $fixedDirectory . $fileName . "." . $extension;

                    /**
                     * This is probably a good path, let's check if the file
                     * exists
                     */
                    if (true === $this->requireFile($filePath)) {
                        /**
                         * Return true mean success
                         */
                        return true;
                    }
                }
            }
        }

        /**
         * Change the namespace separator by directory separator too
         */
        $nsClassName = str_replace($ns, $ds, $className);

        /**
         * Directories
         */
        foreach ($this->directories as $directory) {
            /**
             * Add a trailing directory separator if the user forgot to do that
             */
            $fixedDirectory = rtrim($directory, $ds) . $ds;

            foreach ($this->extensions as $extension) {
                /**
                 * Create a possible path for the file
                 */
                $filePath = $fixedDirectory . $nsClassName . "." . $extension;

                /**
                 * Check in every directory if the class exists here
                 */
                if (true === $this->requireFile($filePath)) {
                    /**
                     * Return true meaning success
                     */
                    return true;
                }
            }
        }

        /**
         * Cannot find the class, return false
         */
        return false;
    }

    /**
     * Returns the class-map currently registered in the autoloader
     *
     * @return array
     */
    public function getClasses(): array
    {
        return $this->classes;
    }

    /**
     * Returns the directories currently registered in the autoloader
     *
     * @return array
     */
    public function getDirs(): array
    {
        return $this->directories;
    }

    /**
     * Returns the file extensions registered in the loader
     *
     * @return array
     */
    public function getExtensions(): array
    {
        return $this->extensions;
    }

    /**
     * Returns the files currently registered in the autoloader
     *
     * @return array
     */
    public function getFiles(): array
    {
        return $this->files;
    }

    /**
     * Returns the namespaces currently registered in the autoloader
     *
     * @return array
     */
    public function getNamespaces(): array
    {
        return $this->namespaces;
    }

    /**
     * Checks if a file exists and then adds the file by doing virtual require
     */
    public function loadFiles(): void
    {
        foreach ($this->files as $file) {
            /**
             * Check if the file specified even exists
             */
            $this->requireFile($file);
        }
    }

    /**
     * Register the autoload method
     *
     * @param bool $prepend
     *
     * @return Loader
     */
    public function register(bool $prepend = false): Loader
    {
        if (true !== $this->registered) {
            /**
             * Loads individual files added using Loader->registerFiles()
             */
            $this->loadFiles();

            /**
             * Registers directories & namespaces to PHP's autoload
             */
            spl_autoload_register(
                [$this, "autoLoad"],
                true,
                $prepend
            );

            $this->registered = true;
        }

        return $this;
    }

    /**
     * Register classes and their locations
     *
     * @param array $classes
     * @param bool  $merge
     *
     * @return Loader
     */
    public function registerClasses(array $classes, bool $merge = false): Loader
    {
        $this->classes = $this->mergeElements("classes", $classes, $merge);

        return $this;
    }

    /**
     * Register directories in which "not found" classes could be found
     *
     * @param array $directories
     * @param bool  $merge
     *
     * @return Loader
     */
    public function registerDirs(array $directories, bool $merge = false): Loader
    {
        $this->directories = $this->mergeElements("directories", $directories, $merge);

        return $this;
    }

    /**
     * Registers files that are "non-classes" hence need a "require". This is
     * very useful for including files that only have functions
     *
     * @param array $files
     * @param bool  $merge
     *
     * @return Loader
     */
    public function registerFiles(array $files, bool $merge = false): Loader
    {
        $this->files = $this->mergeElements("files", $files, $merge);

        return $this;
    }

    /**
     * Register namespaces and their related directories
     *
     * @param array $namespaces
     * @param bool  $merge
     *
     * @return Loader
     */
    public function registerNamespaces(array $namespaces, bool $merge = false): Loader
    {
        $preparedNamespaces = $this->prepareNamespace($namespaces);

        if (true === $merge) {
            foreach ($preparedNamespaces as $name => $paths) {
                if (true !== isset($this->namespaces[$name])) {
                    $this->namespaces[$name] = [];
                }

                $this->namespaces[$name] = array_merge(
                    $this->namespaces[$name],
                    $paths
                );
            }
        } else {
            $this->namespaces = $preparedNamespaces;
        }

        return $this;
    }

    /**
     * Sets an array of file extensions that the loader must try in each attempt
     * to locate the file
     *
     * @param array $extensions
     *
     * @return Loader
     */
    public function setExtensions(array $extensions): Loader
    {
        $this->extensions = $extensions;

        return $this;
    }

    /**
     * Unregister the autoload method
     */
    public function unregister(): Loader
    {
        if (true === $this->registered) {
            spl_autoload_unregister(
                [
                    $this,
                    "autoLoad"
                ]
            );

            $this->registered = false;
        }

        return $this;
    }

    /**
     * @param array $namespaceName
     *
     * @return array
     */
    protected function prepareNamespace(array $namespaceName): array
    {
        $prepared = [];

        foreach ($namespaceName as $name => $path) {
            if (true !== is_array($path)) {
                $path = [$path];
            }

            $prepared[$name] = $path;
        }

        return $prepared;
    }

    /**
     * Check if the file exists and require it
     *
     * @param string $file The file to require.
     *
     * @return bool
     *
     */
    protected function requireFile($file)
    {
        if (true === file_exists($file)) {
            require $file;
            return true;
        }

        return false;
    }

    /**
     * Merges or not two internal arrays
     *
     * @param string $name
     * @param array  $elements
     * @param bool   $merge
     *
     * @return array
     */
    private function mergeElements(string $name, array $elements, bool $merge = false): array
    {
        if (true === $merge) {
            return array_merge($this->$name, $elements);
        } else {
            return $elements;
        }
    }
}
